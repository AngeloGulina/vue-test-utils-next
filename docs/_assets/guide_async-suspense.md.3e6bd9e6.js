import{g as n,f as s,A as a}from"./common-ab061852.js";const t='{"title":"Asynchronous Behavior","frontmatter":{},"headers":[{"level":2,"title":"A Simple Example - Updating with trigger","slug":"a-simple-example-updating-with-trigger"},{"level":2,"title":"Resolving Other Asynchronous Behavior","slug":"resolving-other-asynchronous-behavior"},{"level":2,"title":"Conclusion","slug":"conclusion"}],"lastUpdated":1598528079980.223}';var o={};const e=a('<h1 id="asynchronous-behavior"><a class="header-anchor" href="#asynchronous-behavior" aria-hidden="true">#</a> Asynchronous Behavior</h1><p>You may have noticed some other parts of the guide using <code>await</code> when calling some methods on <code>wrapper</code>, such as <code>trigger</code> and <code>setValue</code>. What&#39;s that all about?</p><p>You might know Vue updates reactively; when you change a value, the DOM is automatically updated to reflect the latest value. Vue does this <em>asynchronously</em>. In contrast, a test runner like Jest runs <em>synchronously</em>. This can cause some surprising results in tests. Let&#39;s look at some strategies to ensure Vue is updating the DOM as expected when we run our tests.</p><h2 id="a-simple-example-updating-with-trigger"><a class="header-anchor" href="#a-simple-example-updating-with-trigger" aria-hidden="true">#</a> A Simple Example - Updating with <code>trigger</code></h2><p>Let&#39;s re-use the <code>&lt;Counter&gt;</code> component from <a href="/guide/event-handling.html">event handling</a> with one change; we now render the <code>count</code> in the <code>template</code>.</p><div class="language-js"><pre><code><span class="token keyword">const</span> Counter <span class="token operator">=</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n    Count: {{ count }}\n    &lt;button @click=&quot;handleClick&quot;&gt;Increment&lt;/button&gt;\n  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      count<span class="token operator">:</span> <span class="token number">0</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  methods<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>Let&#39;s write a test to verify the <code>count</code> is increasing:</p><div class="language-js"><pre><code><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&#39;increments by 1&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> wrapper <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span>Counter<span class="token punctuation">)</span>\n\n  wrapper<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&#39;button&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trigger</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">)</span>\n\n  <span class="token function">expect</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toContain</span><span class="token punctuation">(</span><span class="token string">&#39;Count: 1&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>Surprisingly, this fails! The reason is although <code>count</code> is increased, Vue will not update the DOM until the next &quot;tick&quot; or &quot;render cycle&quot;. For this reason, the assertion will be called before Vue updates the DOM. This has to do with the concept of &quot;marcotasks&quot;, &quot;microtasks&quot; and the JavaScript Event Loop. You can read more details and see a simple example <a href="https://javascript.info/event-loop#macrotasks-and-microtasks" target="_blank" rel="noopener noreferrer">here</a>.</p><p>Implementation details aside, how can we fix this? Vue actually provides a way for us to wait until the DOM is updated: <code>nextTick</code>:</p><div class="language-js"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br></div><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> nextTick <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&#39;increments by 1&#39;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> wrapper <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span>Counter<span class="token punctuation">)</span>\n\n  wrapper<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&#39;button&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trigger</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">)</span>\n  <span class="token keyword">await</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n  <span class="token function">expect</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toContain</span><span class="token punctuation">(</span><span class="token string">&#39;Count: 1&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>Now the test will pass, because we ensure the next &quot;tick&quot; has executed updated the DOM before the assertion runs. Since <code>await nextTick()</code> is common, VTU provides a shortcut. Methods than cause the DOM to update, such as <code>trigger</code> and <code>setValue</code> return <code>nextTick</code>! So you can just <code>await</code> those directly:</p><div class="language-js"><div class="highlight-lines"><br><br><br><div class="highlighted"> </div><br><br><br><br></div><pre><code><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&#39;increments by 1&#39;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> wrapper <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span>Counter<span class="token punctuation">)</span>\n\n  <span class="token keyword">await</span> wrapper<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&#39;button&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trigger</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">)</span>\n\n  <span class="token function">expect</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toContain</span><span class="token punctuation">(</span><span class="token string">&#39;Count: 1&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><h2 id="resolving-other-asynchronous-behavior"><a class="header-anchor" href="#resolving-other-asynchronous-behavior" aria-hidden="true">#</a> Resolving Other Asynchronous Behavior</h2><p><code>nextTick</code> is useful to ensure some change in reactivty data is reflected in the DOM before continuing the test. However, sometimes you may want to ensure other, non Vue-related asynchronous behavior is completed, too. A common example is a function that returns a <code>Promise</code> that will lead to a change in the DOM. Perhaps you mocked your <code>axios</code> HTTP client using <code>jest.mock</code>:</p><div class="language-js"><pre><code>jest<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token string">&#39;axios&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> data<span class="token operator">:</span> <span class="token string">&#39;some mocked data!&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre></div><p>In this case, Vue has no knowledge of the unresolved Promise, so calling <code>nextTick</code> will not work - your assertion may run before it is resolved. For scenarios like this, you can use <code>[flush-promises](https://www.npmjs.com/package/flush-promises)</code>, which causes all outstanding promises to resolve immediately.</p><p>Let&#39;s see an example:</p><div class="language-js"><pre><code><span class="token keyword">import</span> flushPromises <span class="token keyword">from</span> <span class="token string">&#39;flush-promises&#39;</span>\n<span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">&#39;axios&#39;</span>\n\njest<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token string">&#39;axios&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> data<span class="token operator">:</span> <span class="token string">&#39;some mocked data!&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n\n<span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&#39;uses a mocked axios HTTP client and flush-promises&#39;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">// some component that makes a HTTP called in `created` using `axios`</span>\n  <span class="token keyword">const</span> wrapper <span class="token operator">=</span> <span class="token function">mount</span><span class="token punctuation">(</span>AxiosComponent<span class="token punctuation">)</span>\n\n  <span class="token keyword">await</span> <span class="token function">flushPromses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// axios promise is resolved immediately!</span>\n  \n  <span class="token comment">// assertions!</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n</code></pre></div><blockquote><p>If you haven&#39;t tested Components with API requests before, you can learn more in <a href="/guide/http-requests.html">HTTP Requests</a>.</p></blockquote><h2 id="conclusion"><a class="header-anchor" href="#conclusion" aria-hidden="true">#</a> Conclusion</h2><ul><li>Vue updates the DOM asynchronously; tests runner execute code synchronously.</li><li>Use <code>await nextTick()</code> to ensure the DOM has updated before the test continues</li><li>Functions that might update the DOM, like <code>trigger</code> and <code>setValue</code> return <code>nextTick</code>, so you should <code>await</code> them.</li><li>Use <code>flush-promises</code> to resolve any unresolved promises from non-Vue dependencies.</li></ul>',22);o.render=function(a,t,o,p,c,u){return s(),n("div",null,[e])};export default o;export{t as __pageData};
